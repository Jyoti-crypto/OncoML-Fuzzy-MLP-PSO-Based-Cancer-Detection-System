# -*- coding: utf-8 -*-
"""FUZZY-MLP-PSO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zo0XazALtQ2AgEKcyUk31bqDCPQNs4o1
"""

# ==========================================
# Breast Cancer Detection: MLP vs Fuzzy-MLP vs Fuzzy-MLP-PSO (with Convergence Rate)
# ==========================================

import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score, mean_squared_error

# ==========================================
# 1. Data Loading and Preprocessing
# ==========================================
data = load_breast_cancer()
X = data.data
y = data.target.reshape(-1, 1)

scaler = MinMaxScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# ==========================================
# 2. Basic MLP Model
# ==========================================
class MLP:
    def __init__(self, n_input, n_hidden, n_output, lr=0.01, momentum=0.3):
        rng = np.random.default_rng(42)
        self.W1 = rng.uniform(-0.5, 0.5, (n_input, n_hidden))
        self.W2 = rng.uniform(-0.5, 0.5, (n_hidden, n_output))
        self.V1 = np.zeros_like(self.W1)
        self.V2 = np.zeros_like(self.W2)
        self.lr = lr
        self.momentum = momentum

    def sigmoid(self, x):
        return 1 / (1 + np.exp(-x))

    def forward(self, X):
        self.Z1 = self.sigmoid(np.dot(X, self.W1))
        self.Z2 = self.sigmoid(np.dot(self.Z1, self.W2))
        return self.Z2

    def backward(self, X, y):
        output = self.forward(X)
        error = y - output
        dZ2 = error * output * (1 - output)
        dW2 = np.dot(self.Z1.T, dZ2)

        dZ1 = np.dot(dZ2, self.W2.T) * self.Z1 * (1 - self.Z1)
        dW1 = np.dot(X.T, dZ1)

        self.V2 = self.momentum * self.V2 + self.lr * dW2
        self.V1 = self.momentum * self.V1 + self.lr * dW1

        self.W2 += self.V2
        self.W1 += self.V1

        return np.mean(error ** 2)

    def train(self, X, y, epochs=100):
        mse_curve = []
        for _ in range(epochs):
            mse = self.backward(X, y)
            mse_curve.append(mse)
        return mse_curve

    def predict(self, X):
        return (self.forward(X) > 0.5).astype(int)

# ==========================================
# 3. Fuzzy Membership Function
# ==========================================
def s_shaped_membership(x, a, b):
    x = np.clip(x, 0, 1)
    y = np.zeros_like(x)
    idx1 = x <= a
    idx2 = (x > a) & (x < (a + b) / 2)
    idx3 = (x >= (a + b) / 2) & (x < b)
    idx4 = x >= b

    y[idx1] = 0
    y[idx2] = 2 * ((x[idx2] - a) / (b - a)) ** 2
    y[idx3] = 1 - 2 * ((x[idx3] - b) / (b - a)) ** 2
    y[idx4] = 1
    return y

# ==========================================
# 4. PSO Optimizer
# ==========================================
class PSO:
    def __init__(self, model_fn, X, y, n_input, n_hidden, n_output,
                 num_particles=40, iterations=100):
        self.model_fn = model_fn
        self.X = X
        self.y = y
        self.num_particles = num_particles
        self.iterations = iterations
        self.dim = n_input * n_hidden + n_hidden * n_output
        self.rng = np.random.default_rng(42)
        self.positions = self.rng.random((num_particles, self.dim)) - 0.5
        self.velocities = np.zeros_like(self.positions)
        self.pbest = np.copy(self.positions)
        self.gbest = self.positions[0]
        self.pbest_mse = np.full(num_particles, np.inf)
        self.gbest_mse = np.inf
        self.mse_curve = []

    def decode(self, pos):
        n_input = self.X.shape[1]
        n_hidden = int(len(pos) / (n_input + 1))
        split = n_input * n_hidden
        W1 = pos[:split].reshape(n_input, n_hidden)
        W2 = pos[split:].reshape(n_hidden, 1)
        return W1, W2

    def optimize(self):
        w_max, w_min = 0.9, 0.4
        c1, c2 = 2.0, 2.0
        for t in range(self.iterations):
            w = w_max - (w_max - w_min) * (t / self.iterations)
            for i in range(self.num_particles):
                pos = self.positions[i]
                W1, W2 = self.decode(pos)
                model = self.model_fn(W1, W2)
                y_pred = model.forward(self.X)
                mse = mean_squared_error(self.y, y_pred)
                if mse < self.pbest_mse[i]:
                    self.pbest_mse[i] = mse
                    self.pbest[i] = pos
                if mse < self.gbest_mse:
                    self.gbest_mse = mse
                    self.gbest = pos
            self.mse_curve.append(self.gbest_mse)
            r1, r2 = np.random.rand(), np.random.rand()
            self.velocities = (w * self.velocities +
                               c1 * r1 * (self.pbest - self.positions) +
                               c2 * r2 * (self.gbest - self.positions))
            self.positions += self.velocities
        return self.decode(self.gbest), self.mse_curve

# ==========================================
# 5. Run Experiment + Convergence Comparison
# ==========================================
def run_experiment(epochs=100):
    n_input = X_train.shape[1]
    n_hidden = 15
    n_output = 1

    results = {}
    mse_curves = {}

    # --- MLP ---
    mlp = MLP(n_input, n_hidden, n_output, lr=0.01, momentum=0.3)
    mse_curves["MLP"] = mlp.train(X_train, y_train, epochs)
    y_pred = mlp.predict(X_test)
    results["mlp_acc"] = accuracy_score(y_test, y_pred)
    results["mlp_mse"] = mean_squared_error(y_test, mlp.forward(X_test))

    # --- Fuzzy-MLP ---
    fuzz_a = np.percentile(X_train, 10)
    fuzz_b = np.percentile(X_train, 90)
    X_train_fuzzy = s_shaped_membership(X_train, fuzz_a, fuzz_b)
    X_test_fuzzy = s_shaped_membership(X_test, fuzz_a, fuzz_b)
    fuzzy_mlp = MLP(n_input, n_hidden, n_output, lr=0.015, momentum=0.5)
    mse_curves["Fuzzy-MLP"] = fuzzy_mlp.train(X_train_fuzzy, y_train, epochs)
    y_pred_fuzzy = fuzzy_mlp.predict(X_test_fuzzy)
    results["fuzzy_acc"] = accuracy_score(y_test, y_pred_fuzzy)
    results["fuzzy_mse"] = mean_squared_error(y_test, fuzzy_mlp.forward(X_test_fuzzy))

    # --- Fuzzy-MLP-PSO ---
    def model_fn(W1, W2):
        m = MLP(n_input, n_hidden, n_output)
        m.W1 = W1
        m.W2 = W2
        return m

    pso = PSO(model_fn, X_train_fuzzy, y_train, n_input, n_hidden, n_output,
              num_particles=40, iterations=epochs)
    (W1_best, W2_best), mse_pso = pso.optimize()
    best_model = model_fn(W1_best, W2_best)
    mse_curves["Fuzzy-MLP-PSO"] = mse_pso
    y_pred_pso = best_model.predict(X_test_fuzzy)
    results["pso_acc"] = accuracy_score(y_test, y_pred_pso)
    results["pso_mse"] = mean_squared_error(y_test, best_model.forward(X_test_fuzzy))

    return results, mse_curves

# ==========================================
# 6. Plot Accuracy, MSE & Convergence
# ==========================================
def plot_results(results, mse_curves):
    models = ["MLP", "Fuzzy-MLP", "Fuzzy-MLP-PSO"]
    accs = [results["mlp_acc"], results["fuzzy_acc"], results["pso_acc"]]
    mses = [results["mlp_mse"], results["fuzzy_mse"], results["pso_mse"]]

    plt.figure(figsize=(14, 5))

    # --- Bar Graphs ---
    plt.subplot(1, 2, 1)
    plt.bar(models, accs, color=["red", "orange", "green"])
    plt.title("Accuracy Comparison")
    plt.ylabel("Accuracy")

    plt.subplot(1, 2, 2)
    plt.bar(models, mses, color=["red", "orange", "green"])
    plt.title("MSE Comparison")
    plt.ylabel("MSE")

    plt.tight_layout()
    plt.show()

    # --- Convergence Plot ---
    plt.figure(figsize=(8, 5))
    for label, curve in mse_curves.items():
        plt.plot(curve, label=label)
    plt.title("Convergence Rate (MSE vs Epochs)")
    plt.xlabel("Epoch / Iteration")
    plt.ylabel("MSE")
    plt.legend()
    plt.grid(True)
    plt.show()

# ==========================================
# 7. MAIN
# ==========================================
if __name__ == "__main__":
    print("Running MLP vs Fuzzy-MLP vs Fuzzy-MLP-PSO...\n")
    results, mse_curves = run_experiment(epochs=120)
    print("\n--- FINAL RESULTS ---")
    print(f"MLP:           Accuracy = {results['mlp_acc']*100:.2f}%, MSE = {results['mlp_mse']:.5f}")
    print(f"Fuzzy-MLP:     Accuracy = {results['fuzzy_acc']*100:.2f}%, MSE = {results['fuzzy_mse']:.5f}")
    print(f"Fuzzy-MLP-PSO: Accuracy = {results['pso_acc']*100:.2f}%, MSE = {results['pso_mse']:.5f}")
    plot_results(results, mse_curves)